/* 	This is a model of system with multiple CPUs
*	and shared command buffer. Commands are loading
*	to buffer from RAM beforehand.
*/

int bufer = 0;
int BUFFER_CAPACITY = 20;
int completedCommands = 0;
fac RAM("single");
fac CPUs("parallel") {entries = 3};
queue RAM;
queue CPUs;
mark RAMCycle;
mark CPUCycle;

exitwhen(completedCommands > 1);
{{
/* RAM imitation */
: inject("RAM cycling Xact", 0, 0, 0, 1) {priority = 10, p1 = 4, p2 = 5, str1 = "ram"};
RAMCycle: queue_enter(RAM);
: fac_enter(RAM);
: queue_leave(RAM);
: wait(8, 3);
: try(bufer < BUFFER_CAPACITY);
{
: fac_leave(RAM);
: bufer.add(1);
: travel(RAMCycle);
}

/* Multiple CPU system imitation */
: inject("CPUs cycling Xact", 0, 0, 0, 3);
CPUCycle: try(bufer > 0);
{
: queue_enter(CPUs);
: fac_enter(CPUs);
: bufer.subt(1);
: queue_leave(CPUs);
: wait(15, 6);
: fac_leave(CPUs);
: completedCommands.add(1);
/* It was maybe a command which will erase buffer: */
: travel(CPUCycle, 0.9);
: bufer.assign(0);
: travel(CPUCycle);
}
}}
