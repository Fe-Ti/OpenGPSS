int var_name [ = initial_value];
float var_name [ = initial_value];
chain chain_name;
facility facility_name(string mode) {[type params]};
queue queue_name {[type params]};
mark markname1;
tab return_type func_name(type xvalue);
{
xvalue1, yvalue1 / xvalue2, yvalue2 / ... / xvalueN, yvalueN;
[operations]
}

void func_name([type param1, type param2, ...]);
{
:operations
}

return_type func_name([type param1, type param2, ...]);
{
:operations
:return(return_value);
}

entry(str exitmode, int injectedCounter, int rejectedCounter, int tickLimit);
{{
:inject(str name, int time, int tdelta, int delay, int limit) {[type param1, type param2, ...]};
:cond(int op1, string operation, int op2);
{
:operations
}
:[otherwise] [wait;]
{
:operations
}
:name.param_name.add/subt/mult/div/exp(int operand);
:fbusy(facility_name);
:ffree(facility_name);
:qenter(queue_name);
:qleave(queue_name);
:wait(int time, int tdelta);
:travel([float probability, ]string markname_iftrue[, string markname_iffalse]);
markname:reject(int minuscounter);
}}
