```
     ____                ________  ________
    / __ \___  ___ ___  / ___/ _ \/ __/ __/
   / /_/ / _ \/ -_) _ \/ (_ / ___/\ \_\ \
   \____/ .__/\__/_//_/\___/_/  /___/___/
       /_/           by NotSoOld, 2017 (c)
   
   направляй|обрабатывай|собирай статистику
```

---

# OpenGPSS - Инструкция (бета 0.3)

## Содержание
[Основное](#Основное)

[Объявление переменных и структур:](#Объявление-переменных-и-структур)

- [Простые переменные](#Простые-переменные)

- [Структурные типы](#Структурные-типы)

- [Массивы и матрицы](#Массивы-и-матрицы)

[О неоднозначности имён]()

[Исполняемые блоки:]()

[inject](#inject---add-xacts-into-your-system)
\-- [queue_enter](#queue_enter---enter-unordered-queue-to-gather-statistics)
\-- [queue_leave](#queue_leave---leave-previously-entered-unordered-queue)
\-- [fac_enter](#fac_enter---occupy-facility-by-taking-one-of-its-free-places)
\-- [fac_leave](#fac_leave---free-a-place-in-previously-occupied-facility)
\-- [fac_irrupt](#fac_irrupt---force-into-occupied-facility)
\-- [fac_goaway](#fac_goaway---go-away-from-previously-interrupted-facility)
\-- [reject](#reject---delete-xact-entirely-from-system)
\-- [wait](#wait---move-xact-to-fec-for-some-amount-of-time)
\-- [transport/transport_prob/transport_if](#transport-family-blocks---------transport-xact-or-fork-the-path-of-xact)
\-- [if/else_if/else](#ifelse_ifelse---make-xact-follow-different-paths-according-to-some-condition)
\-- [wait_until](#wait_until---block-xact-movement-until-condition-becomes-true)
\-- [chain_enter](#chain_enter---move-xact-to-one-of-user-chains)
\-- [chain_leave](#chain_leave---take-xacts-from-user-chain)
\-- [chain_purge](#chain_purge---take-all-xacts-from-the-user-chain)
\-- [chain_pick](#chain_pick---take-xacts-which-satisfy-a-condition)
\-- [chain_find](#chain_find---take-xacts-from-user-chain-by-index)
\-- [hist_add](#hist_add---add-a-sample-to-the-histogram)
\-- [while](#while---do-i-really-need-to-describe-what-it-does-d)
\-- [loop_times](#loop_times---do-something-as-much-times-as-you-need)
\-- [copy](#copy---make-a-full-copy-of-a-xact)
\-- [output](#output---print-something-when-you-need-to)
\-- [xact_report](#xact_report---print-all-information-about-xact-executing-this-block)
\-- [move](#move---just-skip-that-line)
\-- [interrupt](#interrupt---force-interpreter-to-go-to-next-time-beat)
\-- [review_cec](#review_cec---force-interpreter-to-look-through-cec-from-beginning)
\-- [flush_cec](#flush_cec---clear-cec-entirely)
\-- [pause_by_user](#pause_by_user---halt-simulation-until-user-presses-any-key)

[Встроенные функции:]()

- [Генераторы случайных чисел]()

- [Конвертеры типов]()

- [find()]()

- [find_minmax()]()

- [Математические функции]()

## Основное
Программа на языке OpenGPSS выглядит следующим образом:

```
*область определения переменных*
*условие выхода*
{{
исполняемая область
}}
*опциональная область определения переменных*
{{
еще одна исполняемая область
}}
и т.д.
```

Область определения содержит определения переменных и структур (устройств, очередей, меток и т.д.), которые используются при имитации системы. Каждая линия определения примерно выглядит так:
- для переменных:

`тип имя = начальное значение;`
- для структур:

`тип имя {начальные параметры};`

Каждая строка в OpenGPSS заканчивается точкой с запятой. Если в конце строки нет точки с запятой, это значит, что эта же строка продолжается на следующей линии (т.е. можно записывать длинные строки в несколько линий).
Комментарии - как в Си:
`// Это однострочный комментарий`
```
/* А это - многострочный
комментарий */
```

Во время имитации условие выхода проверяется в конце каждого такта, чтобы убедиться, не пора ли прекращать имитацию модели. Условие выхода определяется ОДИН раз:

`exitwhen(выражение с булевым результатом);`

Когда выражение станет истинно, имитация закончится.

Двойные фигурные скобки `{{` и `}}` отделяют область определения от исполняемой области. Исполняемая область - это область перемещения транзактов, их добавления и удаления, обработки и т.д. Исполняемая область содержит исполняемые блоки:

`необяз.имя_метки : имя_блока(параметры блока);`

присвоения переменным или параметрам транзактов (++/-- также считаются за присвоения):

`необяз.имяметки : имя_переменной = новое_значение/выражение;`

`необяз.имяметки : имя_переменной++;`

и одиночные скобки для блоков *if*/*else_if*/*else*/*while*/*loop_times*.

К параметрам транзактов можно обратиться через точку:

`xact.p1, xact.str5, xact.my_parameter, xact.priority`

(*priority*, приоритет - это специальный параметр, который по умолчанию есть у каждого транзакта; он используется интерпретатором для имитации модели)

Любая исполняемая строка может начинаться с метки (после которой стоит двоеточие - разделитель). Если метка присутствует, это значит, что транзакт можно переместить на этот блок, зная имя метки. **НЕЛЬЗЯ** адресовать метками одиночные фигурные скобки, это приведет к ошибкам (адресуйте блоки до или после них).

Если транзакт достигает какой-нибудь исполняемой строки, он пытается выполнить ее (кроме фигурных скобок и блока *inject* - последний исполняется автоматически время от времени), при этом, если блоку нужны какие-либо параметры транзакта, испольуются параметры именно исполняющего транзакта.

Практически каждый параметр (за исключением специально оговоренных случаев) - имя структуры, выражения в условиях - могут быть не просто словами-строками, а целыми выражениями любой сложности (с операторами +, -, \*, /, ** (возведение в степень), % (остаток от деления), ~ (косвенная адресация) и встроенными функциями). Они будут превращены в значения перед вызовом блока. (исключение - начальные значения параметров, в том числе блока *inject*, т.к. они передаются "как есть", без проверки на выражение. Размеры массивов и начальные значения переменных могут быть выражениями.).

В модели во время имитации есть два важных списка (цепи): *цепь будущих событий*, ЦБС, и *цепь текущих событий*, ЦТС. Время в модели течет дискретно и измеряется в тактах. Каждый такт ЦБС просматривается для извлечения транзактов, которым пора продолжать движение в текущем такте (время продолжения движения указано вместе с транзактом, когда тот находится в ЦБС). Итак, эти транзакты будут извлечены в ЦТС, где, после сортировки транзактов по приоритету, интерпретатор будет просматривать ЦТС транзакт за транзактом, пытаясь продвинуть каждый транзакт по модели, пока тот: а) не будет извлечен из модели б) не будет заблокирован в) не переместится из ЦТС в цепь пользователя г) не выполнит блок *wait*.

В случае а) транзакт будет удален из ЦТС (и из модели совсем).

В случае б), который может быть вызван попыткой занять полностью заполненное устройство или пройти блок *wait\_until*, транзакт останется в ЦТС до следующего такта, во время которого он попытается продвинуться снова.

В случае в) транзакт будет перемещен из ЦТС в одну из цепей пользователя.

В случае г) транзакт будет перемещен в ЦБС с указанием времени дальнейшего продвижения, которое блок *wait* выставит сам.

Новые транзакты могут быть добавлены в модель с помощью блоков *inject* и *copy*. Блок *inject* создает *инжектор* - он добавляет один транзакт в ЦБС с указанием времени выхода в ЦТС (согласно параметрам инжектора). Когда этот транзакт покидает ЦБС, он указывает инжектору, что пора добавить в ЦБС следующий транзакт, и процесс повторяется. Блок *copy* создает копии транзакта, который его исполняет, и эти копии добавляются в ЦТС.

Существует особая ситуация под названием "Пересмотр ЦТС". Когда интерпретатор получает сигнал о том, что нужно пересмотреть ЦТС, он прерывает продвижение текущего транзакта и начинает просмотр ЦТС с самого ее начала. Вызвать пересмотр ЦТС могут, к примеру, такие блоки, как *fac\_leave* или *review\_cec*, а также изменение *приоритета* транзакта. (Зачем так сделано? Эти действия могут влиять на течение процесса моделирования. К примеру, если какой-то транзакт покидает заполненное устройство, то оно становится доступным для транзактов, ожидающих на его входе; но эти транзакты не двигаются, т.к. были заблокированы до этого. При пересмотре ЦТС с начала эти транзакты смогут занять устройство. А изменение приоритета транзакта может влиять на порядок обработки транзактов, на порядок их поступления в устройства, поэтому ЦТС также должна быть пересмотрена.)


## Объявление переменных и структур

**Для всех типов:**

Имя переменной (для получения его в виде строки) может быть получено через точку: *имя\_переменной.name*.

Существует возможность разыменовывания переменных (с помощью тильды, "~"). Т.е. если в какой-то переменной содержится имя другой переменной, то, разыменовав ее, можно получить значение именно второй переменной, имя которой указано в первой переменной:
```
str var1 = "var2";
int var2 = 5;

~var1++; <== значение переменной "var2" увеличится на 1
```

**Также:**

У текущего транзакта (который исполняет блок или операцию присваивания) есть несколько доступных параметров (вкупе с его собственными параметрами). К ним можно обратиться с помощью оператора ".":
```
xact.index
xact.group
```

### Простые переменные:

- int

	Просто переменная, которая может содержать целочисленное значение и доступна по своему имени. Диапазон значений - см. инструкцию языка Python.
	
	Доп. информация:
	
	\- Если целочисленной переменной присвоить значение с плавающей точкой, то оно будет автоматически обрезано до целочисленного.
	
	\- В модели имеется три целочисленных переменных, которые доступны всегда (но только для чтения):
	
	**injected** - количество введенных в модель транзактов;
	
	**rejected** - количество транзактов, извлеченных из модели с помощью блока *reject*;
	
	**curticks** - количество просимулированных тактов (текущий такт моделирования)
	
- float

	Переменная, которая способна хранить значение с плавающей точкой. Диапазон опять же такой же, как в Python.
	
- str

	Переменная, хранящая строку. В то время, как к числовым переменным можно применять все доступные операции, строки можно только присваивать и соединять.
	
- bool

	Переменная, хранящая логическое значение (true/false). Булевы переменные можно только присваивать (и применять в логических выражениях).
	
### Структурные типы:

- fac (facility, устройство)

	Это устройство, которое может быть занято транзактами. Обычно устройство используют, чтобы моделировать что-нибудь, что может быть занято кем-то или чем-то на определенный срок и тем самым остановить продвижение остальных транзактов (те будут ждать, пока устройство освободится). Таким образом, пока устройство имеет свободные места, транзакты могут в него заходить и занимать эти места, но когда устройство заполнено (т.е. занято) транзактами полностью, остальным транзактам придется ждать, пока оно освободится.
	
	Начальные параметры (задаются в фигурных скобках):
	
	\- isQueued = bool *(по умолчанию - true)* - если true, это устройство будет автоматически дополнено очередью, как будто бы имеются блоки *queue\_enter* и *queue\_leave* снизу и сверху от блока *fac\_enter*. Очередь будет названа так же, как называется устройство.
	
	\- places = int *(по умолчанию - 1)* - количество мест в устройстве, т.е. как много транзактов могут занять устройство одновременно до его полной блокировки.
	
	Доступные параметры (с помощью оператора "."):
	
	\- curplaces - сколько свободных мест доступно сейчас

	\- maxplaces - сколько мест имеет устройство в целом

	\- enters_f - сколько транзактов уже успели войти в это устройство

	\- isAvail - текущий статус доступности устройства (это НЕ статус "имеет/не имеет свободных мест", см. блок *fac\_avail*)
	
- queue (очередь)

	Очередь - это приспособление, которое чаще всего используется для сбора статистики о потоке транзактов в определенном месте модели (например, на входе устройства, т.к. именно там чаще всего собираются очереди из транзактов). Собранная статистика будет включать в себя количество вошедших транзактов, среднюю и максимальную длины очереди, среднее время ожидания в очереди и многое другое. Важно понимать, что очередь не является приспособлением для сбора транзактов в некий буфер или для их сортировки - оно не влияет на поток транзактов и лишь наблюдает за ним, записывая определенные параметры.
	
	Начальные параметры: нет.
	
	Доступные параметры (с помощью оператора "."):
	
	\- curxacts - сколько транзактов в данный момент находится в очереди

	\- enters_q - сколько транзактов успели войти в очередь на данный момент
	
- mark (метка)

	Это определение перемещающей метки, которая затем может быть использована в исполняемой части программы. Когда метка находится слева от ':' в строке, она определяет строку, куда транзакты должны быть перемещены, когда данная метка упоминается как точка назначения. Когда метка является аргументом любого из блоков, который способен переносить транзакты в модели, она определяет соответствущую строку в программе, куда транзакт должен направиться.
	
	Начальные параметры: нет.
	
	Доступные параметры: нет.
	
	Доп. информация:
	
	\- Вы всегда будете видеть предупреждения о неопределенных или неиспользуемых метках.
	
- chain (цепь пользователя)

	Цепи пользователя используются как место для хранения транзактов, когда Вам нужно управлять их перемещением в модели. Цепи пользователя позволяют помещать транзакты в буфер (тем самым симулируя устройства-буферы), выпускать транзакты по одному или сразу по несколько в определенную точку модели безусловно или согласно условию и т.д.
	
	Начальные параметры: нет.
	
	Доступные параметры (с помощью оператора "."):
	
	\- length - сколько транзактов находятся в цепи пользователя в данный момент
	
	\- xacts (доступен только для функций find/find\_minmax!) - список текущих транзактов в цепи пользователя
	
- hist<имя\_переменной> (гистограмма)

	Гистограммы - это один из дополнительных способов сбора статистики. Гистограммы могут хранить различные значения одного параметра, которые он принимал, пока менялся в течение симуляции модели. Имя этого параметра указывается в угловых скобках после ключевого слова *hist*. Значение этого параметра будет вычисляться и добавляться в таблицу гистограммы каждый раз, когда исполняется соответствующий блок *hist\_add*. После окончания моделирования, гистограмма будет распечатана как в виде таблицы, так и в псевдографическом виде (столбики значений).
	
	Начальные параметры (**все без исключения** должны быть указаны в фигурных скобках):
	
	\- start - первое граничное значение гистограммы
	
	\ interval - постоянный размер интервала между границами значений "столбиков" (интервалов) гистограммы
	
	\- count - сколько всего будет "столбиков" (без учета интервала от минус бесконечности до *start* и от последней границы до плюс бесконечности).
	
	Графическое представление:
	
	![alt text](./histillustr.jpg)
	
	При добавлении очередного значения параметра в таблицу будет выбран соответствующий интервал, куда это значение попадает. Каждый интервал содержит количество входов значений в него.
	
	Доступные параметры (через "."):
	
	\- enters_h - сколько раз значения добавлялись в гистограмму
	
	\- average - среднее значение наблюдаемого параметра
	
- graph<параметр\_х, параметр\_у> (2D-график)

	Графики - еще один дополительный способ сбора статистики об изменениях тех или иных величин модели. Данный тип позволяет отслеживать изменение двух величин в виде графика (т.е. одна из величин является величиной по оси Х, вторая - по оси Y, и запоминаются они парами). Согласно законам математики, каждому значению Х может соответствовать только одно значение по Y, поэтому, если в таблицу графика будет добавлена пара (X, Y) такая, что Х уже существует в таблице, то итоговая пара будет следующей: (X, (старый\_Y + Y) / 2).
	
	Так как график невозможно построить средствами псевдографики, данный тип выводится в результатах как таблица собранных пар значений. Далее, используя эту таблицу, можно построить график, например, в Excel.
	
	Начальные параметры: нет.
	
	Доступные параметры: нет.
	
	
### Массивы и матрицы:
